// tests/registration/registration-combined.spec.ts
import { test, expect, type Page, type APIRequestContext } from '@playwright/test';
import * as dotenv from 'dotenv';
import * as path from 'path';
import * as fs from 'fs';
import * as fsExtra from 'fs-extra';
import { fileURLToPath } from 'url';

// Get the current directory name in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);


dotenv.config();

test.setTimeout(240000);
test.describe.configure({ mode: 'parallel' });

// ---- Env (typed) ----
const SSO_USERNAME: string = process.env.SSO_USERNAME ?? '';
const SSO_PASSWORD: string = process.env.SSO_PASSWORD ?? '';
const NEW_PASSWORD: string = process.env.NEW_PASSWORD ?? '';
const CONFIRM_PASSWORD: string = process.env.CONFIRM_PASSWORD ?? NEW_PASSWORD;

// Test credentials from environment variables
const TEST_UUID1: string = process.env.TEST_UUID1 ?? '';
const TEST_EMAIL1: string = process.env.TEST_EMAIL1 ?? '';
const TEST_UUID2: string = process.env.TEST_UUID2 ?? '';
const TEST_EMAIL2: string = process.env.TEST_EMAIL2 ?? '';

// Log environment variable status
if (!TEST_UUID1) console.warn('WARNING: TEST_UUID1 is not set in .env file');
if (!TEST_EMAIL1) console.warn('WARNING: TEST_EMAIL1 is not set in .env file');
if (!TEST_UUID2) console.warn('WARNING: TEST_UUID2 is not set in .env file');
if (!TEST_EMAIL2) console.warn('WARNING: TEST_EMAIL2 is not set in .env file');

const LOCALE: string = process.env.LOCALE ?? 'de_DE';
const BASE_URL: string = process.env.BASE_URL ?? 'https://stage.recordati-plus.de/de_DE/account/signin';

export { TEST_UUID1, TEST_UUID2, TEST_EMAIL1, TEST_EMAIL2, LOCALE, BASE_URL };

console.log(`[test] Using BASE_URL: ${BASE_URL}`);

// Test results directory
const TEST_RESULTS_DIR = path.join(__dirname, '../../test-results/registration');

// Ensure test results directory exists
if (!fs.existsSync(TEST_RESULTS_DIR)) {
  fs.mkdirSync(TEST_RESULTS_DIR, { recursive: true });
} else {
  // Clear previous test results
  fsExtra.emptyDirSync(TEST_RESULTS_DIR);
}

// Test results interface
interface TestResult {
  testName: string;
  status: 'passed' | 'failed' | 'skipped';
  startTime: string;
  endTime?: string;
  duration?: number;
  steps: TestStep[];
  error?: string;
  screenshots: string[];
}

interface TestStep {
  name: string;
  status: 'passed' | 'failed' | 'skipped';
  timestamp: string;
  duration?: number;
  error?: string;
}

// Global test results
const testResults: Record<string, TestResult> = {};

// Helper function to capture screenshot
async function captureScreenshot(page: Page, testName: string, stepName: string): Promise<string> {
  const safeTestName = testName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
  const safeStepName = stepName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const screenshotPath = path.join(TEST_RESULTS_DIR, `${safeTestName}_${safeStepName}_${timestamp}.png`);
  
  try {
    await page.screenshot({ path: screenshotPath, fullPage: true });
    return screenshotPath;
  } catch (error) {
    console.error(`Failed to capture screenshot for ${testName} - ${stepName}:`, error);
    return '';
  }
}

// Helper function to generate HTML report
function generateHtmlReport(): void {
  const reportPath = path.join(TEST_RESULTS_DIR, 'test-report.html');
  const tests = Object.values(testResults);
  const passedCount = tests.filter(t => t.status === 'passed').length;
  const failedCount = tests.filter(t => t.status === 'failed').length;
  const skippedCount = tests.filter(t => t.status === 'skipped').length;

  const html = `
  <!DOCTYPE html>
  <html>
  <head>
    <title>Registration Test Results</title>
    <style>
      body { font-family: Arial, sans-serif; margin: 20px; }
      .summary { background: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
      .test { border: 1px solid #ddd; border-radius: 5px; margin-bottom: 15px; padding: 15px; }
      .test-header { font-weight: bold; margin-bottom: 10px; }
      .passed { color: green; }
      .failed { color: red; }
      .skipped { color: orange; }
      .step { margin-left: 20px; margin-bottom: 5px; }
      .screenshot { max-width: 100%; margin-top: 10px; border: 1px solid #ddd; }
      .error { color: red; white-space: pre-wrap; font-family: monospace; }
    </style>
  </head>
  <body>
    <h1>Registration Test Results</h1>
    
    <div class="summary">
      <h2>Summary</h2>
      <p>Total Tests: ${tests.length}</p>
      <p class="passed">Passed: ${passedCount}</p>
      <p class="failed">Failed: ${failedCount}</p>
      <p class="skipped">Skipped: ${skippedCount}</p>
      <p>Success Rate: ${((passedCount / tests.length) * 100).toFixed(2)}%</p>
    </div>
    
    ${tests.map(test => `
      <div class="test">
        <div class="test-header">
          ${test.testName} - 
          <span class="${test.status}">${test.status.toUpperCase()}</span>
          <small>(${test.duration}ms)</small>
        </div>
        
        ${test.error ? `
          <div class="error">
            <strong>Error:</strong><br>
            ${test.error}
          </div>
        ` : ''}
        
        <div class="steps">
          <h3>Steps:</h3>
          ${test.steps.map(step => `
            <div class="step">
              ${step.name} - 
              <span class="${step.status}">${step.status.toUpperCase()}</span>
              <small>(${step.duration}ms)</small>
              ${step.error ? `<div class="error">${step.error}</div>` : ''}
            </div>
          `).join('')}
        </div>
        
        ${test.screenshots.length > 0 ? `
          <div class="screenshots">
            <h3>Screenshots:</h3>
            ${test.screenshots.map(screenshot => `
              <div>
                <p>${path.basename(screenshot)}</p>
                <img src="${path.basename(screenshot)}" class="screenshot" />
              </div>
            `).join('')}
          </div>
        ` : ''}
      </div>
    `).join('')}
  </body>
  </html>
  `;

  fs.writeFileSync(reportPath, html);
  console.log(`Test report generated: ${reportPath}`);
}

// Test helper function
async function runTestStep<T>(
  testName: string,
  stepName: string,
  action: () => Promise<T>,
  page?: Page
): Promise<T> {
  const testResult = testResults[testName] || {
    testName,
    status: 'passed',
    startTime: new Date().toISOString(),
    steps: [],
    screenshots: []
  };

  const stepStartTime = Date.now();
  const step: TestStep = {
    name: stepName,
    status: 'passed',
    timestamp: new Date().toISOString()
  };

  try {
    testResults[testName] = testResult;
    testResult.steps.push(step);
    
    const result = await action();
    
    // Capture screenshot after successful step if page is provided
    if (page) {
      const screenshotPath = await captureScreenshot(page, testName, stepName);
      if (screenshotPath) {
        testResult.screenshots.push(screenshotPath);
      }
    }
    
    return result;
  } catch (error) {
    step.status = 'failed';
    step.error = error instanceof Error ? error.message : String(error);
    testResult.status = 'failed';
    testResult.error = step.error;
    
    // Capture screenshot on failure if page is provided
    if (page) {
      try {
        const screenshotPath = await captureScreenshot(page, testName, `${stepName}_error`);
        if (screenshotPath) {
          testResult.screenshots.push(screenshotPath);
        }
      } catch (screenshotError) {
        console.error('Failed to capture error screenshot:', screenshotError);
      }
    }
    
    throw error;
  } finally {
    step.duration = Date.now() - stepStartTime;
    
    // Update test duration
    if (testResult.startTime) {
      const startTime = new Date(testResult.startTime).getTime();
      testResult.duration = Date.now() - startTime;
    }
    
    // Save test results to file after each step
    fs.writeFileSync(
      path.join(TEST_RESULTS_DIR, 'test-results.json'),
      JSON.stringify(testResults, null, 2)
    );
  }
}

// Process exit handler to ensure report is generated
process.on('exit', () => {
  try {
    generateHtmlReport();
  } catch (error) {
    console.error('Error generating HTML report:', error);
  }
});

// ---------- Accept cookies helper ----------
async function acceptCookiesIfVisible(page: Page, required: boolean = true) {
  console.log('[cookies] Waiting for cookie banner to appear...');
  
  // Wait for the "Alle akzeptieren" button to be visible
  const acceptBtn = page.getByRole('button', { name: 'Alle akzeptieren' });
  
  if (required) {
    // Wait for banner to appear - will fail if not found
    await acceptBtn.waitFor({ state: 'visible', timeout: 30000 });
    console.log('[cookies] ✓ Cookie banner is visible');
  } else {
    // Optional wait - skip if banner doesn't appear
    try {
      await acceptBtn.waitFor({ state: 'visible', timeout: 5000 });
      console.log('[cookies] ✓ Cookie banner is visible');
    } catch (err) {
      console.log('[cookies] No cookie banner found (already accepted or not present)');
      return;
    }
  }
  
  // Scroll to the button to ensure it's in view
  await acceptBtn.scrollIntoViewIfNeeded();
  console.log('[cookies] ✓ Scrolled to button');
  
  // Wait a moment for any animations
  await page.waitForTimeout(500);
  
  // Click the button with force to bypass any overlays
  await acceptBtn.click({ force: true });
  console.log('[cookies] ✓ Clicked "Alle akzeptieren" button');
  
  // Wait for banner to disappear
  await page.waitForTimeout(1500);
  
  // Verify the banner is gone
  const isBannerGone = !(await acceptBtn.isVisible().catch(() => false));
  if (isBannerGone) {
    console.log('[cookies] ✓ Cookies accepted successfully - banner dismissed');
  } else {
    console.log('[cookies] ⚠️ Button clicked but banner still visible');
  }
}

// ---------- Capture consent and confirm ----------
async function captureConsentAndOpenInNewTab(
  page: Page,
  request: APIRequestContext,
  locale: string
) {
  console.log('[consent] Setting up GET request listener...');

  // Set up GET request listener to capture consent parameters
  let consentParams: { domain?: string; local?: string; token?: string; userId?: string } = {};
  
  page.on('response', async (response) => {
    const url = response.url();
    if (url.includes('/api/registration/registration-confirm')) {
      console.log('[consent] GET response intercepted:', url);
      
      try {
        // Extract parameters from URL
        const urlObj = new URL(url);
        const headers = response.headers();
        
        console.log('[consent] Response URL:', url);
        console.log('[consent] Response headers:', Object.keys(headers));
        
        // Extract from URL parameters
        consentParams.domain = urlObj.searchParams.get('domain') || consentParams.domain;
        consentParams.local = urlObj.searchParams.get('local') || consentParams.local;
        consentParams.token = urlObj.searchParams.get('token') || consentParams.token;
        consentParams.userId = urlObj.searchParams.get('user_id') || consentParams.userId;
        
        // Extract from headers if not in URL
        consentParams.token = headers['x-consent-token'] || headers['consent-token'] || consentParams.token;
        consentParams.userId = headers['x-user-id'] || headers['user-id'] || consentParams.userId;
        consentParams.domain = headers['x-domain'] || headers['domain'] || consentParams.domain;
        consentParams.local = headers['x-local'] || headers['local'] || consentParams.local;
        
        console.log('[consent] Extracted parameters:', consentParams);
        
      } catch (err) {
        console.log('[consent] Error processing response:', err instanceof Error ? err.message : String(err));
      }
    }
  });

  console.log('[consent] Clicking "Ich stimme zu" button...');
  await page.getByRole('button', { name: 'Ich stimme zu' }).click();

  console.log('[consent] Waiting for consent parameters to be captured...');
  
  // Wait for parameters to be captured
  await expect
    .poll(() => {
      console.log('[consent-poll] Current parameters:', consentParams);
      return (consentParams.token && consentParams.userId) ? 'ok' : null;
    }, {
      timeout: 15000,
      message: `consent parameters not captured. params=${JSON.stringify(consentParams)}`,
    })
    .toBe('ok');

  console.log('[consent] ✓ Successfully captured parameters:', consentParams);

  // Create consent confirmation URL with extracted parameters
  const baseUrl = 'https://stage.recordati-plus.de';
  const domain = consentParams.domain || 'de_DE';
  const local = consentParams.local || 'de_DE';
  const confirmUrl = `${baseUrl}/api/registration/consent-confirm?token=${consentParams.token}&country_lang=${local}&user_id=${consentParams.userId}`;
  
  console.log(`[consent] Created confirmation URL: ${confirmUrl}`);
  
  try {
    // Make a direct HTTP request to confirm consent
    console.log('[consent] Sending confirmation request...');
    const response = await page.request.get(confirmUrl, {
      timeout: 30000,
      headers: {
        'Referer': 'https://stage.recordati-plus.de/',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
      }
    });
    
    const status = response.status();
    console.log(`[consent-confirm] Confirmation request completed with status: ${status}`);
    
    // If we get here, the consent was successfully confirmed
    console.log('[test] ✓ Registration journey completed successfully');
    expect([200, 204, 302]).toContain(status);
  } catch (error) {
    console.log('[consent] Error during confirmation request:', error);
    throw error;
  }
}

// =====================================================
// Test 1: Registration flow (Positive Journey) @optout
// =====================================================
test('Registration flow (Positive Journey) @optout', async ({ page, request }) => {
  const testName = 'registration_optout';
  const testStartTime = Date.now();
  
  // Initialize test result
  testResults[testName] = {
    testName: 'Registration Flow (Opt-Out)',
    status: 'passed',
    startTime: new Date().toISOString(),
    steps: [],
    screenshots: []
  };
  
  try {
    const TEST_UUID = TEST_UUID1;
    const TEST_EMAIL = TEST_EMAIL1;
    console.log(`[test] Using UUID: ${TEST_UUID}, EMAIL: ${TEST_EMAIL}, BASE_URL: ${BASE_URL}`);

    // --- SSO ---
    console.log('Navigating to BASE_URL:', BASE_URL);
    try {
      await page.goto(BASE_URL, { waitUntil: 'domcontentloaded', timeout: 60000 });
    } catch (error) {
      console.error('Initial navigation failed, retrying...', error);
      await page.goto(BASE_URL, { waitUntil: 'domcontentloaded', timeout: 60000 });
    }

    console.log('Filling SSO credentials');
    await page.getByRole('textbox', { name: 'Username' }).fill(SSO_USERNAME!);
    await page.getByRole('textbox', { name: 'Password' }).fill(SSO_PASSWORD!);
    
    console.log('Clicking Sign In button');
    const signInBtn = page.getByRole('button', { name: 'Sign In' });
    await signInBtn.click();

    // --- Registration page ---
    console.log('Current URL after sign-in:', page.url());
    if (!page.url().includes(BASE_URL)) {
      console.log('Navigating to registration page');
      await page.goto(BASE_URL, { waitUntil: 'domcontentloaded', timeout: 60000 });
    }
    await acceptCookiesIfVisible(page);
    await page.locator('#registerCheckbox').check();
    
    // Wait for page to be fully loaded
    await page.waitForSelector('input[name="uuid"]', { state: 'visible' });

    // Fill LANR field
    const lanrInput = page.locator('input[name="uuid"]');
    await lanrInput.fill(TEST_UUID1);
    await lanrInput.press('Tab');  // Using Tab to trigger blur/validation
    screenshots: []
  };
  
  try {
    const TEST_UUID = TEST_UUID1;
    const TEST_EMAIL = TEST_EMAIL1;
    console.log(`[test] Using UUID: ${TEST_UUID}, EMAIL: ${TEST_EMAIL}, BASE_URL: ${BASE_URL}`);

    // --- SSO ---
    // --- SSO ---
    console.log('Navigating to BASE_URL:', BASE_URL);
    try {
      await page.goto(BASE_URL, { waitUntil: 'domcontentloaded', timeout: 60000 });
    } catch (error) {
      console.error('Initial navigation failed, retrying...', error);
      await page.goto(BASE_URL, { waitUntil: 'domcontentloaded', timeout: 60000 });
    }

    console.log('Filling SSO credentials');
    await page.getByRole('textbox', { name: 'Username' }).fill(SSO_USERNAME!);
    await page.getByRole('textbox', { name: 'Password' }).fill(SSO_PASSWORD!);
    
    console.log('Clicking Sign In button');
    const signInBtn = page.getByRole('button', { name: 'Sign In' });
    await signInBtn.click();
    
    // // Wait for navigation to complete with a timeout
    // try {
    //   await page.waitForNavigation({ waitUntil: 'networkidle', timeout: 60000 });
    // } catch (error) {
    //   console.log('Navigation timeout, continuing with current page');
    // }

    // --- Registration page ---
    console.log('Current URL after sign-in:', page.url());
    if (!page.url().includes(BASE_URL)) {
      console.log('Navigating to registration page');
      await page.goto(BASE_URL, { waitUntil: 'domcontentloaded', timeout: 60000 });
    }
    await acceptCookiesIfVisible(page);
    await page.locator('#registerCheckbox').check();
    
    // Wait for page to be fully loaded
    // await page.waitForLoadState('networkidle');
    await page.waitForSelector('input[name="uuid"]', { state: 'visible' });

    // Fill LANR field
    const lanrInput = page.locator('input[name="uuid"]');
    await lanrInput.fill(TEST_UUID1);
    await lanrInput.press('Tab');  // Using Tab to trigger blur/validation
    
    // Wait for validation with better error handling
    try {
        await expect(page.getByText('Gültige LANR', { exact: false }))
            .toBeVisible({ timeout: 10000 });
        console.log('✓ LANR validation successful');
    } catch (error) {
        // Safely handle error and take screenshot if page is still available
        try {
            if (page && !page.isClosed()) {
                await page.screenshot({ path: 'lanr-validation-failed.png' }).catch(e => 
                    console.error('Failed to take screenshot:', e.message)
                );
                const pageContent = await page.content().catch(e => 'Could not get page content: ' + e.message);
                console.log('Page content at time of failure:', pageContent);
            }
        } catch (e) {
            console.error('Error during error handling:', e);
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error('LANR validation failed: ' + errorMessage);
    }
    
    // Fill email field
    const emailInput = page.locator('input[name="email"]');
    await emailInput.fill(TEST_EMAIL1);
    await emailInput.press('ArrowRight');
    
    // Wait for email validation
    await expect(page.getByText('Email Addresse ist gültig', { exact: false })).toBeVisible();

    // Click Weiter button
    const weiterBtn = page.getByRole('button', { name: 'Weiter', exact: true });
    await expect(weiterBtn).toBeEnabled();
    await weiterBtn.click();

    // Profile
    await page.locator('input[name="telephone"]').fill('+49 5050 6060');
    await page.locator('.form-outline .select-arrow').first().click();
    await page.getByText('Herr', { exact: false }).click();

    // Consents (opt-out path)
    await page.locator('input[name="consentList.948901de-b940-476b-a5f3-d7d27c4f111c"]').check();
    await page.locator('input[name="consentList.74cd22d7-5c2f-4495-ac67-fb8b68afa62f"]').check();
    await page.locator('input[name="consentList.aa539788-311f-4c6f-bf15-120fb6600de6"]').check();

    // Hit consent-confirm in a new tab
    await captureConsentAndOpenInNewTab(page, request, LOCALE);

    // Wait 30 seconds before negative checks
    console.log('[test] Waiting 10 seconds before negative checks...');
    await page.waitForTimeout(10000);
    console.log('[test] ✓ 30-second wait complete');

    // Negative checks - Open a new browser page for fresh session
    console.log('[test] Opening new browser page for negative checks...');
    const negativePage = await page.context().newPage();
    console.log('[test] ✓ New page opened');
    
    try {
      // Negative check 1: UUID already exists
      console.log('[test] Starting negative check 1: UUID validation...');
      await negativePage.goto(BASE_URL, { waitUntil: 'domcontentloaded' });
      console.log('[test] ✓ Navigated to BASE_URL');
      
      await acceptCookiesIfVisible(negativePage, false);
      console.log('[test] ✓ Cookie acceptance completed');
      
      await negativePage.locator('#registerCheckbox').check();
      const lanrInput = negativePage.locator('input[name="uuid"]');
      await lanrInput.fill(TEST_UUID1);
      await lanrInput.press('ArrowRight');
      console.log('[test] ✓ Filled UUID:', TEST_UUID1);
      
      await expect(negativePage.getByText('Mit dieser LANR gibt es', { exact: false })).toBeVisible({ timeout: 10000 });
      console.log('[test] ✓ Negative check 1 passed: UUID already exists');

      // Negative check 2: Email already exists
      console.log('[test] Starting negative check 2: Email validation...');
      await negativePage.goto(BASE_URL, { waitUntil: 'domcontentloaded' });
      console.log('[test] ✓ Navigated to BASE_URL');
      
      await acceptCookiesIfVisible(negativePage, false);
      console.log('[test] ✓ Cookie acceptance completed');
      
      await negativePage.locator('#registerCheckbox').check();
      await negativePage.locator('input[name="email"]').fill(TEST_EMAIL);
      await negativePage.locator('input[name="email"]').press('ArrowRight');
      console.log('[test] ✓ Filled email:', TEST_EMAIL);
      
      await expect(negativePage.getByText('Email ist bereits vorhanden', { exact: false })).toBeVisible({ timeout: 10000 });
      console.log('[test] ✓ Negative check 2 passed: Email already exists');
    } finally {
      await negativePage.close();
      console.log('[test] ✓ Closed negative test page');
    }
  } catch (error) {
    testResults[testName].status = 'failed';
    testResults[testName].error = error instanceof Error ? error.message : String(error);
    throw error;
  } finally {
    try {
      // Update test duration
      if (testResults[testName].startTime) {
        const startTime = new Date(testResults[testName].startTime).getTime();
        testResults[testName].duration = Date.now() - startTime;
      }
      
      // Save test results
      fs.writeFileSync(
        path.join(TEST_RESULTS_DIR, 'test-results.json'),
        JSON.stringify(testResults, null, 2)
      );
      
      // Generate HTML report
      generateHtmlReport();
    } catch (error) {
      console.error('Error in test cleanup:', error);
    }
  }
});

// =====================================================
// Test 2: Registration flow (Positive Journey) @optin
// =====================================================
test('Registration flow (Positive Journey) @optin', async ({ page }) => {
  const testName = 'registration_optin';
  const testStartTime = Date.now();
  
  // Initialize test result
  testResults[testName] = {
    testName: 'Registration Flow (Opt-In)',
    status: 'passed',
    startTime: new Date().toISOString(),
    steps: [],
    screenshots: []
  };
  
  try {
    // Set test-specific credentials
    const TEST_UUID = TEST_UUID2;
    const TEST_EMAIL = TEST_EMAIL2;
    
    // SSO
    await page.goto(BASE_URL);
    await page.getByRole('textbox', { name: 'Username' }).fill(SSO_USERNAME!);
    await page.getByRole('textbox', { name: 'Password' }).fill(SSO_PASSWORD!);
    const signInBtn = page.getByRole('button', { name: 'Sign In' });
    await Promise.all([
      page.waitForNavigation({ waitUntil: 'load' }).catch(() => { }),
      signInBtn.click(),
    ]);

    console.log('Current URL after sign-in:', page.url());
    if (!page.url().includes(BASE_URL)) {
      console.log('Navigating to registration page');
      await page.goto(BASE_URL, { waitUntil: 'domcontentloaded', timeout: 60000 });
    }
    await acceptCookiesIfVisible(page);
    await page.locator('#registerCheckbox').check();
    
    // Fill LANR field
    const lanrInput = page.locator('input[name="uuid"]');
    await lanrInput.fill(TEST_UUID2);
    await lanrInput.press('ArrowRight');
    await expect(page.getByText('Gültige LANR', { exact: false })).toBeVisible();
    
    // Fill email field
    const emailInput = page.locator('input[name="email"]');
    await emailInput.fill(TEST_EMAIL2);
    await emailInput.press('ArrowRight');
    await expect(page.getByText('Email Addresse ist gültig', { exact: false })).toBeVisible();

    const weiterBtn = page.getByRole('button', { name: 'Weiter' });
    await expect(weiterBtn).toBeEnabled();
    await weiterBtn.click();

    // Telephone + salutation
    await page.locator('input[name="telephone"]').fill('+49 4546 56');
    await page.locator('.form-outline .select-arrow').first().click();
    await page.getByText('Herr', { exact: false }).click();

    // Single consent (opt-in)
    await page.locator('input[name="consentList.948901de-b940-476b-a5f3-d7d27c4f111c"]').check();

    // Final Confirmation
    await page.getByRole('button', { name: 'Ich stimme zu' }).click();

    // Wait for success banner to appear
    console.log('[test] Waiting for success banner to appear...');
    await page.waitForTimeout(20000); // Wait for banner animation/appearance
    console.log('[test] ✓ Banner wait complete');

    // Wait for navigation to password setup page
    console.log('[test] Waiting for password setup page...');
    try {
        await page.waitForURL('**/password-setup*', { timeout: 10000 });
        console.log('[test] ✓ Navigated to password setup page');
    } catch (error) {
        if (page.url().includes('/password-setup')) {
            console.log('[test] ✓ Already on password setup page');
        } else {
            console.log('[test] Current URL:', page.url());
            throw new Error('Did not navigate to password setup page');
        }
    }

    // Fill password fields
    await page.locator('input[name="new_password"]').fill(NEW_PASSWORD!);
    await page.locator('input[name="confirm_password"]').fill(CONFIRM_PASSWORD!);
    await page.getByRole('button', { name: 'Weiter' }).click();

    // Wait for navigation to overview page with more robust waiting
    console.log('[test] Waiting for overview page...');
    const currentUrl = page.url();
    console.log(`[test] Current URL before navigation: ${currentUrl}`);

    try {
        // Wait for any navigation to start
        await Promise.all([
            page.waitForNavigation({ 
                timeout: 10000,
                waitUntil: 'domcontentloaded' 
            }).catch(e => console.log('[test] No navigation started within 10s, continuing...')),
            page.getByRole('button', { name: 'Weiter' }).click()
        ]);

        // Wait for URL to change
        await page.waitForFunction(
            (currentUrl) => window.location.href !== currentUrl,
            currentUrl,
            { timeout: 10000 }
        );
        console.log(`[test] URL changed to: ${page.url()}`);

        // Wait for specific URL with retry logic
        const maxRetries = 3;
        let retryCount = 0;
        let success = false;

        while (retryCount < maxRetries && !success) {
            try {
                await page.waitForURL('**/overview-page*', { 
                    timeout: 10000,
                    waitUntil: 'domcontentloaded'
                });
                success = true;
                console.log('[test] Successfully navigated to overview page');
            } catch (e) {
                retryCount++;
                console.log(`[test] Navigation attempt ${retryCount} failed, retrying...`);
                if (retryCount === maxRetries) {
                    console.error('[test] All navigation attempts failed');
                    throw e;
                }
                await page.waitForTimeout(2000); // Wait before retry
            }
        }
    } catch (error) {
        console.error('[test] Failed to navigate to overview page. Current URL:', page.url());
        console.error('[test] Page title:', await page.title());
        throw error;
    }

    // Verify overview page UI is loaded
    console.log('[test] Verifying overview page UI...');
    await expect(page.locator('.py-3').first()).toBeVisible({ timeout: 10000 });
    console.log('[test] ✓ Overview page UI loaded successfully');
  } catch (error) {
    testResults[testName].status = 'failed';
    testResults[testName].error = error instanceof Error ? error.message : String(error);
    throw error;
  } finally {
    try {
      // Update test duration
      if (testResults[testName].startTime) {
        const startTime = new Date(testResults[testName].startTime).getTime();
        testResults[testName].duration = Date.now() - startTime;
      }
      
      // Save test results
      fs.writeFileSync(
        path.join(TEST_RESULTS_DIR, 'test-results.json'),
        JSON.stringify(testResults, null, 2)
      );
      
      // Generate HTML report
      generateHtmlReport();
    } catch (error) {
      console.error('Error in test cleanup:', error);
    }
  }
});
